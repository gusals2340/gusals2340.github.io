<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Shapefile Viewer</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; background-color: #f0f2f5; }
        .card-custom { box-shadow: 0 4px 8px rgba(0,0,0,0.05); border: none; }
        #map { height: 80vh; border-radius: .375rem; }
        .row.g-3 {
            height: 80vh;
            align-items: stretch;
        }
        .col-lg-8, .col-lg-4 {
            height: 100%;
        }
        #main-sidebar-card,
        .card.card-custom {
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        .card-body.tab-content {
            flex: 1 1 auto;
            height: 100%;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }
        .tab-pane {
            flex: 1 1 auto;
            height: 100%;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }
        #layer-list-content,
        #csv-list-content,
        #json-list-content {
            flex: 1 1 auto;
            min-height: 0;
            height: 100%;
            overflow-y: auto;
            position: relative;
        }
        #layer-list-content .text-center,
        #csv-list-content .text-center,
        #json-list-content .text-center {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            margin: 0;
            padding: 0;
            text-align: center;
        }
        .layer-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-bottom: 1px solid #eee;
            min-height: 50px; /* 일관된 높이를 위해 최소 높이 추가 */
        }
        .layer-item:last-child { border-bottom: none; }
        .layer-item .layer-name {
            flex-grow: 1;
            margin-left: 0.75rem;
            font-size: 0.95rem;
            display: flex; /* 텍스트 수직 중앙 정렬을 위해 flex 사용 */
            align-items: center;
        }
        .btn-icon-text .fa-fw { margin-right: 0.5rem; }
        .drag-over { border: 2px dashed #007bff; background-color: #e9f5ff; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
    <div class="container-fluid my-3">
        <header class="bg-white p-3 rounded-3 card-custom mb-3"> 
            <div class="d-flex flex-wrap align-items-center justify-content-between">
                <h1 class="h4 mb-0 me-3"><i class="fas fa-map-location-dot text-primary"></i> Advanced SHP Viewer</h1>
                <div class="btn-toolbar">
                    <div class="input-group me-2">
                        <span class="input-group-text">단순화 허용 오차</span>
                        <input type="number" id="simplification-tolerance" class="form-control" value="0.0001" step="0.0001" min="0">
                    </div>
                    <div class="btn-group me-2" role="group">
                        <label for="folder-input" class="btn btn-primary btn-icon-text">
                            <i class="fa-solid fa-folder-open fa-fw"></i> 폴더 열기
                            <input type="file" id="folder-input" webkitdirectory directory style="display: none;" data-last-path-key="lastFolderOpenPath">
                        </label>
                        <label for="file-input" class="btn btn-primary btn-icon-text">
                            <i class="fa-solid fa-file-lines fa-fw"></i> 파일 추가
                            <input type="file" id="file-input" accept=".shp,.shx,.dbf,.prj,.cpg,.xlsx,.json" multiple style="display: none;" data-last-path-key="lastFileOpenPath">
                        </label>
                    </div>
                    <div class="btn-group" role="group">
                         <button id="toggle-base-map-btn" class="btn btn-secondary btn-icon-text">
                            <i class="fa-solid fa-map"></i> 배경 지도 On/Off
                        </button>
                         <button id="delete-selected-btn" class="btn btn-danger btn-icon-text">
                            <i class="fa-solid fa-check-square fa-fw"></i> 선택 삭제
                        </button>
                         <button id="clear-all-btn" class="btn btn-danger btn-icon-text">
                            <i class="fa-solid fa-trash fa-fw"></i> 전체 삭제
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <div class="row g-3">
            <div class="col-lg-8">
                <div class="card card-custom h-100">
                    <div id="map" class="card-body p-0"></div>
                </div>
            </div>
            <div class="col-lg-4">
                <div id="main-sidebar-card" class="card card-custom">
                    <div class="card-header bg-white p-0">
                        <ul class="nav nav-tabs card-header-tabs" id="myTab" role="tablist">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active" id="layers-tab" data-bs-toggle="tab" data-bs-target="#layers" type="button" role="tab" aria-controls="layers" aria-selected="true"><i class="fa-solid fa-layer-group"></i> 레이어</button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="xlsx-tab" data-bs-toggle="tab" data-bs-target="#xlsx" type="button" role="tab" aria-controls="xlsx" aria-selected="false"><i class="fa-solid fa-file-excel"></i> XLSX</button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="json-tab" data-bs-toggle="tab" data-bs-target="#json" type="button" role="tab" aria-controls="json" aria-selected="false"><i class="fa-solid fa-file-code"></i> JSON</button>
                            </li>
                        </ul>
                    </div>
                    <div class="card-body p-0 tab-content" id="myTabContent">
                        <div class="tab-pane fade show active" id="layers" role="tabpanel" aria-labelledby="layers-tab">
                            <div id="layer-list-content" class="p-0">
                                <div class="text-center text-muted p-5">
                                    <i class="fa-solid fa-file-import fa-2x mb-3"></i>
                                    <p>폴더나 파일을 선택하여<br>레이어를 추가하세요.</p>
                                </div>
                            </div>
                        </div>
                        <div class="tab-pane fade" id="xlsx" role="tabpanel" aria-labelledby="xlsx-tab">
                            <div id="xlsx-list-content" class="p-0">
                                <div class="text-center text-muted p-2">
                                    <i class="fa-solid fa-file-excel fa-2x mb-3"></i>
                                    <p>XLSX 파일을 추가하세요.</p>
                                </div>
                            </div>
                        </div>
                        <div class="tab-pane fade" id="json" role="tabpanel" aria-labelledby="json-tab">
                            <div id="json-list-content" class="p-0">
                                <div class="text-center text-muted p-5">
                                    <i class="fa-solid fa-file-code fa-2x mb-3"></i>
                                    <p>JSON 파일을 추가하세요.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Progress Modal -->
    <div class="modal fade" id="progressModal" tabindex="-1" aria-labelledby="progressModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="progressModalLabel">파일 처리 중...</h5>
                </div>
                <div class="modal-body">
                    <p id="progressText" class="text-center mb-2">잠시만 기다려주세요...</p>
                    <div class="progress">
                        <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="cancel-processing-btn">취소</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- shp.js는 이제 워커에서 로드됩니다. -->

    <script>
        const map = L.map('map').setView([37.5665, 126.9780], 10);
        let loadedLayers = {};
        let loadedCsvs = {}; // 로드된 CSV 파일 정보를 저장할 객체
        let loadedJsons = {}; // 로드된 JSON 파일 정보를 저장할 객체
        let loadedXlsx = {};
        let shpWorker = null; // 웹 워커 인스턴스
        let processingTasks = []; // 워커에게 보낼 준비된 작업 목록
        let processedCount = 0;
        let totalTasks = 0;

        const progressModal = new bootstrap.Modal(document.getElementById('progressModal'));

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' }).addTo(map);

        document.getElementById('folder-input').addEventListener('change', (e) => {
            processFiles(e.target.files);
            if (e.target.files.length > 0 && e.target.files[0].webkitRelativePath) {
                const path = e.target.files[0].webkitRelativePath.split('/').slice(0, -1).join('/');
                localStorage.setItem(e.target.dataset.lastPathKey, path);
            }
            e.target.value = null;
        });
        document.getElementById('file-input').addEventListener('change', (e) => {
            handleAllFiles(e.target.files);
            if (e.target.files.length > 0) {
                const path = e.target.files[0].path || e.target.files[0].webkitRelativePath;
                if (path) {
                    localStorage.setItem(e.target.dataset.lastPathKey, path.substring(0, path.lastIndexOf('/')));
                }
            }
            e.target.value = null;
        });
        document.getElementById('clear-all-btn').addEventListener('click', clearAllLayers);
        document.getElementById('delete-selected-btn').addEventListener('click', deleteSelectedLayers);
        document.getElementById('cancel-processing-btn').addEventListener('click', cancelProcessing);
        document.getElementById('toggle-base-map-btn').addEventListener('click', toggleBaseMap);

        let osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors' });
        osmLayer.addTo(map); // 초기에는 지도에 추가

        function toggleBaseMap() {
            console.log("Toggle Base Map button clicked.");
            if (map.hasLayer(osmLayer)) {
                console.log("OSM layer is currently on. Turning off.");
                map.removeLayer(osmLayer);
            } else {
                console.log("OSM layer is currently off. Turning on.");
                map.addLayer(osmLayer);
            }
            console.log("OSM layer visibility after toggle: ", map.hasLayer(osmLayer));
        }

        // Drag and Drop 이벤트 리스너 추가
        const mainSidebarCard = document.getElementById('main-sidebar-card');

        mainSidebarCard.addEventListener('dragover', (e) => {
            e.preventDefault(); // 기본 동작 방지 (파일 열림 방지)
            e.stopPropagation();
            mainSidebarCard.classList.add('drag-over');
        });

        mainSidebarCard.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            mainSidebarCard.classList.remove('drag-over');
        });

        mainSidebarCard.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            mainSidebarCard.classList.remove('drag-over');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleAllFiles(files);
            }
        });

        async function processFiles(files) {
            if (files.length === 0) return;

            // 기존 워커가 있다면 종료하고 초기화
            if (shpWorker) {
                shpWorker.terminate();
                shpWorker = null;
            }
            processingTasks = [];
            processedCount = 0;
            totalTasks = 0;

            const fileGroups = new Map();
            Array.from(files).forEach(file => {
                const name = file.name.toLowerCase();
                const ext = name.split('.').pop();
                const baseName = name.replace(`.${ext}`, '');
                if (!fileGroups.has(baseName)) fileGroups.set(baseName, {});
                fileGroups.get(baseName)[ext] = file;
            });

            const tasksToPrepare = [];
            const duplicateLayerNames = [];

            for (const [baseName, group] of fileGroups.entries()) {
                const originalCaseBaseName = group.shp ? group.shp.name.replace(/\.shp$/i, '') : baseName;
                if (group.shp && group.shx && group.dbf) {
                    if (loadedLayers[originalCaseBaseName]) {
                        duplicateLayerNames.push(originalCaseBaseName);
                    } else {
                        tasksToPrepare.push({ name: originalCaseBaseName, group: group });
                    }
                }
            }

            if (tasksToPrepare.length === 0) {
                if (duplicateLayerNames.length > 0) alert(`[정보] 선택한 파일 (${duplicateLayerNames.join(', ')})은(는) 이미 불러온 레이어입니다.`);
                else alert("[오류] 유효한 Shapefile 세트를 찾을 수 없습니다.");
                return;
            }

            // 파일 데이터를 ArrayBuffer로 미리 읽어 워커에게 보낼 준비
            // 이 부분은 메인 스레드에서 실행되지만, 파일 읽기 자체는 비교적 빠름
            for (const task of tasksToPrepare) {
                const shpBuffer = await readFileAsArrayBuffer(task.group.shp);
                const dbfBuffer = await readFileAsArrayBuffer(task.group.dbf);
                const prjBuffer = task.group.prj ? await readFileAsArrayBuffer(task.group.prj) : null;
                processingTasks.push({ name: task.name, shpBuffer, dbfBuffer, prjBuffer });
            }

            totalTasks = processingTasks.length;
            processedCount = 0;

            const progressBar = document.getElementById('progressBar');
            const progressText = document.getElementById('progressText');
            progressBar.style.width = '0%';
            progressBar.setAttribute('aria-valuenow', 0);
            progressText.textContent = `(0/${totalTasks}) 처리 중...`;

            progressModal.show();
            // 모달이 완전히 표시되도록 대기 (UI 렌더링 보장)
            await new Promise(resolve => requestAnimationFrame(resolve));

            // 웹 워커 생성 및 메시지 리스너 설정
            shpWorker = new Worker('shp_worker.js');

            const simplificationTolerance = parseFloat(document.getElementById('simplification-tolerance').value);

            shpWorker.onmessage = async (e) => { // async 추가
                const { type, geojson, name, error, current, total } = e.data;

                if (type === 'progress_update') {
                    // 워커로부터 진행 상황 업데이트 받기
                    // current는 1부터 시작하는 현재 처리 중인 파일의 인덱스
                    let progress = Math.round(((current - 1) / total) * 100); // 현재 처리 중인 파일은 아직 완료되지 않았으므로 -1
                    // 파일이 하나만 있을 경우, 0%에서 멈춰있는 것처럼 보이지 않도록 최소 1% 설정
                    if (current === 1 && progress === 0 && total > 0) {
                        progress = 1;
                    }
                    progressBar.style.width = `${progress}%`;
                    progressBar.setAttribute('aria-valuenow', progress);
                    progressText.textContent = `(${current}/${total}) 처리 중: ${name}`;
                } else if (type === 'shp_processed') {
                    // 워커로부터 처리 완료된 GeoJSON 데이터 받기
                    try {
                        const layer = createGeoJSONLayer(geojson);
                        // 여기서 해당 SHP 파일의 ID를 찾아 loadedLayers에 저장해야 합니다.
                        // SHP 파일 이름 (name)과 CSV의 SOURCE 컬럼을 매칭하여 ID를 찾습니다.
                        let layerId = null;
                        for (const csvName in loadedCsvs) {
                            if (loadedCsvs.hasOwnProperty(csvName)) {
                                const csvData = parseCsvData(loadedCsvs[csvName].content);
                                if (csvData[name] && csvData[name].ID) { // name은 SHP 파일 이름 (확장자 제외)
                                    layerId = parseInt(csvData[name].ID, 10);
                                    break;
                                }
                            }
                        }
                        loadedLayers[name] = { layer: layer, visible: true, id: layerId }; // id 추가
                        // map.addLayer(layer); // 여기서 바로 추가하지 않고, 나중에 정렬 후 추가
                    } catch (err) {
                        console.error(`Error adding layer for ${name}:`, err);
                    }
                    // 파일 하나가 성공적으로 처리되었으므로 processedCount 증가
                    processedCount++;
                    const progress = Math.round((processedCount / totalTasks) * 100);
                    progressBar.style.width = `${progress}%`;
                    progressBar.setAttribute('aria-valuenow', progress);
                    progressText.textContent = `(${processedCount}/${totalTasks}) 처리 완료: ${name}`;
                } else if (type === 'shp_error') {
                    console.error(`Error from worker for ${name}:`, error);
                    // 오류가 발생한 파일도 처리된 것으로 간주하여 진행률을 업데이트
                    processedCount++;
                    const progress = Math.round((processedCount / totalTasks) * 100);
                    progressBar.style.width = `${progress}%`;
                    progressBar.setAttribute('aria-valuenow', progress);
                    progressText.textContent = `(${processedCount}/${totalTasks}) 오류 발생: ${name}`;
                } else if (type === 'processing_complete') {
                    // 모든 작업 완료
                    // 최종적으로 100%로 설정
                    progressBar.style.width = '100%';
                    progressBar.setAttribute('aria-valuenow', 100);
                    progressText.textContent = `(${totalTasks}/${totalTasks}) 모든 파일 처리 완료!`;
                    await new Promise(resolve => setTimeout(resolve, 500)); // 100%를 잠시 보여줌
                    progressModal.hide();
                    if (shpWorker) shpWorker.terminate();
                    shpWorker = null;

                    // 모든 작업 완료 후 레이어 정렬 및 추가
                    console.log("Loaded Layers before sorting:", loadedLayers);
                    const sortedLayerNames = Object.keys(loadedLayers).sort((a, b) => {
                        const idA = loadedLayers[a].id !== null ? loadedLayers[a].id : Infinity;
                        const idB = loadedLayers[b].id !== null ? loadedLayers[b].id : Infinity;
                        return idA - idB; // ID가 낮은 것이 먼저 오도록 (오름차순)
                    });
                    console.log("Sorted Layer Names (lowest ID last, for drawing on top):");
                    sortedLayerNames.forEach(name => {
                        console.log(`  ${name} (ID: ${loadedLayers[name].id})`);
                    });

                    // 기존 레이어 모두 제거 (loadedLayers에 있는 레이어만 제거)
                    map.eachLayer(function(layer) {
                        // Leaflet 레이어에 name 옵션이 없으므로, loadedLayers의 layer 객체와 비교
                        for (const name in loadedLayers) {
                            if (loadedLayers.hasOwnProperty(name) && loadedLayers[name].layer === layer) {
                                map.removeLayer(layer);
                                break;
                            }
                        }
                    });

                    // 정렬된 순서대로 레이어 추가
                    console.log("Adding layers to map in sorted order:");
                    sortedLayerNames.forEach(name => {
                        const layerInfo = loadedLayers[name];
                        if (layerInfo.visible) {
                            map.addLayer(layerInfo.layer);
                            console.log(`  Added layer: ${name} (ID: ${loadedLayers[name].id})`);
                        }
                    });

                    updateLayerList(); // <--- 모든 작업 완료 후 한 번만 호출합니다.
                    const allLoadedBounds = L.featureGroup(Object.values(loadedLayers).map(l => l.layer)).getBounds();
                    if(allLoadedBounds.isValid()) map.fitBounds(allLoadedBounds);
                } else if (type === 'processing_cancelled') {
                    // 워커로부터 취소 완료 메시지 받기
                    progressModal.hide();
                    alert("작업이 사용자에 의해 취소되었습니다.");
                    if (shpWorker) shpWorker.terminate();
                    shpWorker = null;
                    updateLayerList(); // <--- 취소 후 한 번만 호출합니다.
                };
            };

            shpWorker.onerror = (error) => {
                console.error("Web Worker error:", error);
                progressModal.hide();
                alert("파일 처리 중 웹 워커 오류가 발생했습니다. 콘솔을 확인하세요.");
                if (shpWorker) shpWorker.terminate();
                shpWorker = null;
                updateLayerList();
            };

            // 워커에게 처리할 작업 목록 전송 (transferable 객체로 효율적으로 전송)
            const transferableObjects = [];
            processingTasks.forEach(task => {
                transferableObjects.push(task.shpBuffer, task.dbfBuffer);
                if (task.prjBuffer) transferableObjects.push(task.prjBuffer);
            });
            shpWorker.postMessage({ type: 'start_processing', payload: { tasks: processingTasks, simplificationTolerance: simplificationTolerance } }, transferableObjects);

            if (duplicateLayerNames.length > 0) {
                alert(`[정보] 선택한 파일 (${duplicateLayerNames.join(', ')})은(는) 이미 불러온 레이어입니다.`);
            }
        }

        function cancelProcessing() {
            if (shpWorker) {
                shpWorker.postMessage({ type: 'cancel_processing' });
                // 워커가 종료 메시지를 보낼 때까지 기다리거나, 즉시 종료할 수도 있음
                // 여기서는 워커가 스스로 종료 메시지를 보내도록 함
            }
        }

        async function processJsonFiles(files) {
            if (files.length === 0) return;

            for (const file of Array.from(files)) {
                if (file.name.toLowerCase().endsWith('.json')) {
                    try {
                        const content = await readFileAsText(file);
                        loadedJsons[file.name] = { name: file.name, content: content };
                        updateJsonList();
                    } catch (error) {
                        console.error(`JSON 파일 로드 중 오류 발생: ${file.name}`, error);
                        alert(`JSON 파일 로드 실패: ${file.name}`);
                    }
                }
            }
        }

        function updateJsonList() {
            const container = document.getElementById('json-list-content');
            container.innerHTML = '';
            const jsonNames = Object.keys(loadedJsons);

            if (jsonNames.length === 0) {
                container.innerHTML = `<div class="text-center text-muted p-5"><i class="fa-solid fa-file-code fa-2x mb-3"></i><p>JSON 파일을 추가하세요.</p></div>`;
                return;
            }

            jsonNames.forEach(name => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'layer-item'; // 기존 레이어 아이템 스타일 재활용
                
                const jsonNameSpan = document.createElement('span');
                jsonNameSpan.className = 'layer-name';
                jsonNameSpan.textContent = name;
                itemDiv.appendChild(jsonNameSpan);

                // 삭제 버튼 추가
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-sm btn-danger';
                deleteBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                deleteBtn.title = 'JSON 삭제';
                deleteBtn.addEventListener('click', () => {
                    if (confirm(`JSON 파일 '${name}'을(를) 삭제하시겠습니까?`)) {
                        delete loadedJsons[name];
                        updateJsonList();
                    }
                });
                itemDiv.appendChild(deleteBtn);

                container.appendChild(itemDiv);
            });
        }

        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = err => reject(err);
                reader.readAsText(file);
            });
        }

        function updateLayerList() {
            const container = document.getElementById('layer-list-content');
            container.innerHTML = '';
            const layerNames = Object.keys(loadedLayers);

            if (layerNames.length === 0) {
                container.innerHTML = `<div class="text-center text-muted p-5"><i class="fa-solid fa-layer-group fa-2x mb-3"></i><p>폴더나 파일을 선택하여<br>레이어를 추가하세요.</p></div>`;
                return;
            }

            layerNames.forEach(name => {
                const item = loadedLayers[name];
                const itemDiv = document.createElement('div');
                itemDiv.className = 'layer-item';
                
                // Checkbox for selection
                const selectCheckbox = document.createElement('input');
                selectCheckbox.className = 'form-check-input';
                selectCheckbox.type = 'checkbox';
                selectCheckbox.dataset.layerName = name;
                itemDiv.appendChild(selectCheckbox);

                // Layer name span
                const layerNameSpan = document.createElement('span');
                layerNameSpan.className = 'layer-name';
                layerNameSpan.textContent = name;
                itemDiv.appendChild(layerNameSpan);

                // Switch for visibility
                const switchDiv = document.createElement('div');
                switchDiv.className = 'form-check form-switch';
                const toggleInput = document.createElement('input');
                toggleInput.className = 'form-check-input';
                toggleInput.type = 'checkbox';
                toggleInput.role = 'switch';
                if (item.visible) {
                    toggleInput.checked = true;
                }
                switchDiv.appendChild(toggleInput);
                itemDiv.appendChild(switchDiv);
                
                // Append the main itemDiv to the container
                container.appendChild(itemDiv);

                // Add event listener to the toggle switch
                toggleInput.addEventListener('change', (e) => {
                    item.visible = e.target.checked;
                    if (item.visible) map.addLayer(item.layer); else map.removeLayer(item.layer);
                });
            });
        }

        function deleteSelectedLayers() {
            const checkboxes = document.querySelectorAll('#layer-list-content .form-check-input[type="checkbox"]:checked');
            if (checkboxes.length === 0) { alert("삭제할 레이어를 선택하세요."); return; }
            checkboxes.forEach(cb => {
                const layerName = cb.getAttribute('data-layer-name');
                if (loadedLayers[layerName]) {
                    map.removeLayer(loadedLayers[layerName].layer);
                    delete loadedLayers[layerName];
                }
            });
            updateLayerList();
        }

        function clearAllLayers() {
            if (Object.keys(loadedLayers).length === 0 && Object.keys(loadedCsvs).length === 0 && Object.keys(loadedJsons).length === 0 && Object.keys(loadedXlsx).length === 0) { alert("삭제할 항목이 없습니다."); return; }
            if (confirm("정말로 모든 레이어, CSV, JSON, XLSX 파일을 삭제하시겠습니까?")) {
                // 지도에서 모든 레이어 제거
                Object.values(loadedLayers).forEach(item => map.removeLayer(item.layer));
                loadedLayers = {};
                
                // 로드된 CSV 및 JSON 데이터 초기화
                loadedCsvs = {};
                loadedJsons = {};
                loadedXlsx = {};

                // UI 업데이트
                updateLayerList();
                updateCsvList();
                updateJsonList();
                updateXlsxList();
            }
        }

        function createGeoJSONLayer(geojson) {
            return L.geoJSON(geojson, {
                style: (feature) => {
                    const featureShpFileName = feature.properties._shpFileName;
                    let matchedStyleId = null;
                    let style = null;

                    // CSV + XLSX 모두 순회하며 매칭되는 스타일 ID 찾기
                    const allCsvSources = { ...loadedCsvs, ...loadedXlsx };
                    for (const csvName in allCsvSources) {
                        if (allCsvSources.hasOwnProperty(csvName)) {
                            const csvData = parseCsvData(allCsvSources[csvName].content);
                            if (csvData[featureShpFileName] && csvData[featureShpFileName].STYLE) {
                                matchedStyleId = parseInt(csvData[featureShpFileName].STYLE, 10);
                                break;
                            }
                        }
                    }

                    // styleMap (기본 style_20241224_hkmc.json)에서 스타일 찾기
                    if (matchedStyleId !== null) {
                        style = styleMap[matchedStyleId];
                    }

                    // 로드된 다른 JSON 파일에서 스타일 찾기 (필요하다면)
                    if (!style) {
                        for (const jsonName in loadedJsons) {
                            if (loadedJsons.hasOwnProperty(jsonName)) {
                                try {
                                    const jsonData = JSON.parse(loadedJsons[jsonName].content);
                                    if (Array.isArray(jsonData)) {
                                        const foundStyle = jsonData.find(s => s.id === matchedStyleId);
                                        if (foundStyle) {
                                            style = foundStyle;
                                            break;
                                        }
                                    } else if (jsonData[matchedStyleId]) {
                                        style = jsonData[matchedStyleId];
                                        break;
                                    }
                                } catch (e) {
                                    console.error(`JSON 파일 파싱 오류: ${jsonName}`, e);
                                }
                            }
                        }
                    }

                    if (style) {
                        const colorArray = style.color && style.color[0] ? style.color[0] : null;
                        const fillColor = colorArray ? `#${colorArray[0].substring(0, 6)}` : '#808080';
                        const color = colorArray ? `#${colorArray[1].substring(0, 6)}` : '#000000';
                        const fillOpacity = colorArray ? parseInt(colorArray[0].substring(6, 8), 16) / 255 : 0.5;
                        const opacity = colorArray ? parseInt(colorArray[1].substring(6, 8), 16) / 255 : 1.0;
                        return {
                            fillColor: fillColor,
                            color: color,
                            weight: 2,
                            opacity: opacity,
                            fillOpacity: fillOpacity
                        };
                    }
                    return { color: '#000000', weight: 2, opacity: 1, fillColor: '#808080', fillOpacity: 0.5 };
                },
                onEachFeature: (feature, layer) => {
                    if (feature.properties) {
                        let popupContent = '<div style="max-height: 200px; overflow-y: auto;"><strong>속성:</strong><table class="table table-striped table-sm mt-2">';
                        for (let key in feature.properties) { popupContent += `<tr><th>${key}</th><td>${feature.properties[key]}</td></tr>`; }
                        popupContent += '</table></div>';
                        layer.bindPopup(popupContent);
                    }
                }
            });
        }

        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = err => reject(err);
                reader.readAsArrayBuffer(file);
            });
        }

        // CSV 데이터를 파싱하여 맵 형태로 저장
        function parseCsvData(csvContent) {
            const lines = csvContent.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) return {};
            
            const headers = lines[0].split(',');
            const dataMap = {};
            
            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',');
                const row = {};
                headers.forEach((header, index) => {
                    row[header.trim()] = values[index] ? values[index].trim() : '';
                });
                // SOURCE 컬럼을 키로 사용
                if (row.SOURCE) { // NAME 대신 SOURCE 사용
                    dataMap[row.SOURCE] = row;
                }
            }
            return dataMap;
        }

        let styleMap = {}; // 스타일 정보를 저장할 객체

        async function loadStyles() {
            try {
                const response = await fetch('./config/style_20241224_hkmc.json'); // 로컬 경로로 변경
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const styles = await response.json();
                styles.forEach(s => {
                    styleMap[s.id] = s;
                });
                console.log("스타일 정보 로드 완료:", styleMap);
            } catch (error) {
                console.error("스타일 정보를 로드하는 데 실패했습니다:", error);
            }
        }

        // 페이지 로드 시 스타일 로드
        loadStyles();

        async function processXlsxFiles(files) {
            if (files.length === 0) return;
            for (const file of Array.from(files)) {
                if (file.name.toLowerCase().endsWith('.xlsx')) {
                    try {
                        const data = await file.arrayBuffer();
                        const workbook = XLSX.read(data, { type: 'array' });
                        workbook.SheetNames.forEach(sheetName => {
                            const csvContent = XLSX.utils.sheet_to_csv(workbook.Sheets[sheetName]);
                            const key = `${file.name.replace(/\.xlsx$/i, '')}_${sheetName}.csv`;
                            loadedXlsx[key] = { name: key, content: csvContent };
                        });
                        updateXlsxList();
                    } catch (error) {
                        console.error(`XLSX 파일 로드 중 오류 발생: ${file.name}`, error);
                        alert(`XLSX 파일 로드 실패: ${file.name}`);
                    }
                }
            }
        }

        function updateXlsxList() {
            const container = document.getElementById('xlsx-list-content');
            container.innerHTML = '';
            const xlsxNames = Object.keys(loadedXlsx);
            if (xlsxNames.length === 0) {
                container.innerHTML = `<div class="text-center text-muted p-2"><i class="fa-solid fa-file-excel fa-2x mb-3"></i><p>XLSX 파일을 추가하세요.</p></div>`;
                return;
            }
            [...xlsxNames].reverse().forEach(name => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'layer-item';
                // 전체선택용 체크박스
                const selectCheckbox = document.createElement('input');
                selectCheckbox.className = 'form-check-input xlsx-check';
                selectCheckbox.type = 'checkbox';
                selectCheckbox.dataset.xlsxName = name;
                itemDiv.appendChild(selectCheckbox);
                // 이름
                const xlsxNameSpan = document.createElement('span');
                xlsxNameSpan.className = 'layer-name';
                xlsxNameSpan.textContent = name;
                itemDiv.appendChild(xlsxNameSpan);
                // 삭제 버튼
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn btn-sm btn-danger';
                deleteBtn.innerHTML = '<i class="fa-solid fa-trash"></i>';
                deleteBtn.title = 'XLSX 삭제';
                deleteBtn.addEventListener('click', () => {
                    if (confirm(`XLSX 파일 '${name}'을(를) 삭제하시겠습니까?`)) {
                        delete loadedXlsx[name];
                        updateXlsxList();
                    }
                });
                itemDiv.appendChild(deleteBtn);
                container.appendChild(itemDiv);
            });
        }

        function deleteSelectedXlsx() {
            const checkboxes = document.querySelectorAll('#xlsx-list-content .xlsx-check:checked');
            if (checkboxes.length === 0) { alert('삭제할 XLSX를 선택하세요.'); return; }
            checkboxes.forEach(cb => {
                const name = cb.getAttribute('data-xlsx-name');
                if (loadedXlsx[name]) delete loadedXlsx[name];
            });
            updateXlsxList();
        }

        function handleAllFiles(files) {
            if (!files || files.length === 0) return;
            const shpFiles = Array.from(files).filter(file => file.name.toLowerCase().endsWith('.shp'));
            const dbfFiles = Array.from(files).filter(file => file.name.toLowerCase().endsWith('.dbf'));
            const shxFiles = Array.from(files).filter(file => file.name.toLowerCase().endsWith('.shx'));
            const prjFiles = Array.from(files).filter(file => file.name.toLowerCase().endsWith('.prj'));
            const cpgFiles = Array.from(files).filter(file => file.name.toLowerCase().endsWith('.cpg'));
            const xlsxFiles = Array.from(files).filter(file => file.name.toLowerCase().endsWith('.xlsx'));
            const jsonFiles = Array.from(files).filter(file => file.name.toLowerCase().endsWith('.json'));
            // shp, dbf, shx 중 하나라도 있으면 레이어 처리
            if (shpFiles.length > 0 || dbfFiles.length > 0 || shxFiles.length > 0) {
                processFiles(files);
            }
            if (xlsxFiles.length > 0) {
                processXlsxFiles(xlsxFiles);
            }
            if (jsonFiles.length > 0) {
                processJsonFiles(jsonFiles);
            }
        }

    </script>
</body>
</html>